
#include "IntanCommon.h"

#include <cmath>
#include <numbers>


// Enable or disable DSP offset removal filter
void IntanCommon::enableDsp(bool enabled)
{
    dspEn = (enabled ? 1 : 0);
}

// Enable or disable impedance checking mode
void IntanCommon::enableZcheck(bool enabled)
{
	zcheckEn = (enabled ? 1 : 0);
}

// Power up or down impedance checking DAC
void IntanCommon::setZcheckDacPower(bool enabled)
{
	zcheckDacPower = (enabled ? 1 : 0);
}

// Select the series capacitor used to convert the voltage waveform generated by the on-chip
// DAC into an AC current waveform that stimulates a selected electrode for impedance testing
// (ZcheckCs100fF, ZcheckCs1pF, or Zcheck10pF).
void IntanCommon::setZcheckScale(ZcheckCs scale)
{
    switch (scale) {
        case ZcheckCs100fF:
            zcheckScale = 0x00;     // Cs = 0.1 pF
            break;
        case ZcheckCs1pF:
            zcheckScale = 0x01;     // Cs = 1.0 pF
            break;
        case ZcheckCs10pF:
            zcheckScale = 0x03;     // Cs = 10.0 pF
            break;
    }
}

// Set the DSP offset removal filter cutoff frequency as closely to the requested
// newDspCutoffFreq (in Hz) as possible; returns the actual cutoff frequency (in Hz).
double IntanCommon::setDspCutoffFreq(double newDspCutoffFreq)
{
	double x, fCutoff[16], logNewDspCutoffFreq, logFCutoff[16], minLogDiff;

	fCutoff[0] = 0.0;   // We will not be using fCutoff[0], but we initialize it to be safe

	logNewDspCutoffFreq = log10(newDspCutoffFreq);

	// Generate table of all possible DSP cutoff frequencies
	for (int n = 1; n < 16; ++n) {
		x = pow(2.0, (double)n);
		fCutoff[n] = sampleRate * log(x / (x - 1.0)) / (2 * std::numbers::pi);
		logFCutoff[n] = log10(fCutoff[n]);
		// cout << "  fCutoff[" << n << "] = " << fCutoff[n] << " Hz" << endl;
	}

	// Now find the closest value to the requested cutoff frequency (on a logarithmic scale)
	if (newDspCutoffFreq > fCutoff[1]) {
		dspCutoffFreq = 1;
	}
	else if (newDspCutoffFreq < fCutoff[15]) {
		dspCutoffFreq = 15;
	}
	else {
		minLogDiff = 10000000.0;
		for (int n = 1; n < 16; ++n) {
            if (fabs(logNewDspCutoffFreq - logFCutoff[n]) < minLogDiff) {
                minLogDiff = fabs(logNewDspCutoffFreq - logFCutoff[n]);
				dspCutoffFreq = n;
			}
		}
	}

	return fCutoff[dspCutoffFreq];
}


// Returns the current value of the DSP offset removal cutoff frequency (in Hz).
double IntanCommon::getDspCutoffFreq() const
{
	double x = pow(2.0, static_cast<double>(dspCutoffFreq));

	return sampleRate * log(x / (x - 1.0)) / (2 * std::numbers::pi);
}

// Returns the value of the RH1 resistor (in ohms) corresponding to a particular upper
// bandwidth value (in Hz).
double IntanCommon::rH1FromUpperBandwidth(double upperBandwidth) const
{
	double log10f = log10(upperBandwidth);

	return 0.9730 * pow(10.0, (8.0968 - 1.1892 * log10f + 0.04767 * log10f * log10f));
}

// Returns the value of the RH2 resistor (in ohms) corresponding to a particular upper
// bandwidth value (in Hz).
double IntanCommon::rH2FromUpperBandwidth(double upperBandwidth) const
{
	double log10f = log10(upperBandwidth);

	return 1.0191 * pow(10.0, (8.1009 - 1.0821 * log10f + 0.03383 * log10f * log10f));
}

// Returns the value of the RL resistor (in ohms) corresponding to a particular lower
// bandwidth value (in Hz).
double IntanCommon::rLFromLowerBandwidth(double lowerBandwidth) const
{
	double log10f = log10(lowerBandwidth);

	if (lowerBandwidth < 4.0) {
		return 1.0061 * pow(10.0, (4.9391 - 1.2088 * log10f + 0.5698 * log10f * log10f +
			0.1442 * log10f * log10f * log10f));
	}
	else {
		return 1.0061 * pow(10.0, (4.7351 - 0.5916 * log10f + 0.08482 * log10f * log10f));
	}
}

// Returns the amplifier upper bandwidth (in Hz) corresponding to a particular value
// of the resistor RH1 (in ohms).
double IntanCommon::upperBandwidthFromRH1(double rH1) const
{
	double a, b, c;

	a = 0.04767;
	b = -1.1892;
	c = 8.0968 - log10(rH1 / 0.9730);

	return pow(10.0, ((-b - sqrt(b * b - 4 * a * c)) / (2 * a)));
}

// Returns the amplifier upper bandwidth (in Hz) corresponding to a particular value
// of the resistor RH2 (in ohms).
double IntanCommon::upperBandwidthFromRH2(double rH2) const
{
	double a, b, c;

	a = 0.03383;
	b = -1.0821;
	c = 8.1009 - log10(rH2 / 1.0191);

	return pow(10.0, ((-b - sqrt(b * b - 4 * a * c)) / (2 * a)));
}

// Returns the amplifier lower bandwidth (in Hz) corresponding to a particular value
// of the resistor RL (in ohms).
double IntanCommon::lowerBandwidthFromRL(double rL) const
{
    double a, b, c;

    // Quadratic fit below is invalid for values of RL less than 5.1 kOhm
    if (rL < 5100.0) {
        rL = 5100.0;
    }

    if (rL < 30000.0) {
        a = 0.08482;
        b = -0.5916;
        c = 4.7351 - log10(rL/1.0061);
    } else {
        a = 0.3303;
        b = -1.2100;
        c = 4.9873 - log10(rL/1.0061);
    }

    return pow(10.0, ((-b - sqrt(b * b - 4 * a * c))/(2 * a)));
}

// Sets the on-chip RH1 and RH2 DAC values appropriately to set a particular amplifier
// upper bandwidth (in Hz).  Returns an estimate of the actual upper bandwidth achieved.
double IntanCommon::setUpperBandwidth(double upperBandwidth)
{
    const double RH1Base = 2200.0;
    const double RH1Dac1Unit = 600.0;
    const double RH1Dac2Unit = 29400.0;
    const int RH1Dac1Steps = 63;
    const int RH1Dac2Steps = 31;

    const double RH2Base = 8700.0;
    const double RH2Dac1Unit = 763.0;
    const double RH2Dac2Unit = 38400.0;
    const int RH2Dac1Steps = 63;
    const int RH2Dac2Steps = 31;

    double actualUpperBandwidth;
    double rH1Target, rH2Target;
    double rH1Actual, rH2Actual;
    int i;

    // Upper bandwidths higher than 30 kHz don't work well with the RHD2000 amplifiers
    if (upperBandwidth > 30000.0) {
        upperBandwidth = 30000.0;
    }

    rH1Target = rH1FromUpperBandwidth(upperBandwidth);

    rH1Dac1 = 0;
    rH1Dac2 = 0;
    rH1Actual = RH1Base;

    for (i = 0; i < RH1Dac2Steps; ++i) {
        if (rH1Actual < rH1Target - (RH1Dac2Unit - RH1Dac1Unit / 2)) {
            rH1Actual += RH1Dac2Unit;
            ++rH1Dac2;
        }
    }

    for (i = 0; i < RH1Dac1Steps; ++i) {
        if (rH1Actual < rH1Target - (RH1Dac1Unit / 2)) {
            rH1Actual += RH1Dac1Unit;
            ++rH1Dac1;
        }
    }

    rH2Target = rH2FromUpperBandwidth(upperBandwidth);

    rH2Dac1 = 0;
    rH2Dac2 = 0;
    rH2Actual = RH2Base;

    for (i = 0; i < RH2Dac2Steps; ++i) {
        if (rH2Actual < rH2Target - (RH2Dac2Unit - RH2Dac1Unit / 2)) {
            rH2Actual += RH2Dac2Unit;
            ++rH2Dac2;
        }
    }

    for (i = 0; i < RH2Dac1Steps; ++i) {
        if (rH2Actual < rH2Target - (RH2Dac1Unit / 2)) {
            rH2Actual += RH2Dac1Unit;
            ++rH2Dac1;
        }
    }

    double actualUpperBandwidth1, actualUpperBandwidth2;

    actualUpperBandwidth1 = upperBandwidthFromRH1(rH1Actual);
    actualUpperBandwidth2 = upperBandwidthFromRH2(rH2Actual);

    // Upper bandwidth estimates calculated from actual RH1 value and acutal RH2 value
    // should be very close; we will take their geometric mean to get a single
    // number.
    actualUpperBandwidth = sqrt(actualUpperBandwidth1 * actualUpperBandwidth2);

    /*
    cout << endl;
    cout << "Rhd2000Registers::setUpperBandwidth" << endl;
    cout << fixed << setprecision(1);

    cout << "RH1 DAC2 = " << rH1Dac2 << ", DAC1 = " << rH1Dac1 << endl;
    cout << "RH1 target: " << rH1Target << " Ohms" << endl;
    cout << "RH1 actual: " << rH1Actual << " Ohms" << endl;

    cout << "RH2 DAC2 = " << rH2Dac2 << ", DAC1 = " << rH2Dac1 << endl;
    cout << "RH2 target: " << rH2Target << " Ohms" << endl;
    cout << "RH2 actual: " << rH2Actual << " Ohms" << endl;

    cout << "Upper bandwidth target: " << upperBandwidth << " Hz" << endl;
    cout << "Upper bandwidth actual: " << actualUpperBandwidth << " Hz" << endl;

    cout << endl;
    cout << setprecision(6);
    cout.unsetf(ios::floatfield);
    */

    return actualUpperBandwidth;
}